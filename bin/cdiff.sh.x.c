#if 0
	shc Version 3.9.6, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f cdiff.sh 
#endif

static  char data [] = 
#define      lsto_z	1
#define      lsto	((&data[0]))
	"\031"
#define      tst1_z	22
#define      tst1	((&data[1]))
	"\231\014\234\013\160\116\111\210\141\307\171\200\271\331\024\044"
	"\137\310\207\101\375\006\362\111\307\023\133"
#define      xecc_z	15
#define      xecc	((&data[30]))
	"\113\347\156\145\034\220\374\301\075\316\251\151\334\116\325\262"
	"\223\125\074\261"
#define      chk1_z	22
#define      chk1	((&data[48]))
	"\325\233\307\140\056\126\107\156\325\042\357\043\021\167\310\277"
	"\250\316\214\111\320\150\162"
#define      msg2_z	19
#define      msg2	((&data[75]))
	"\071\222\266\112\214\352\327\006\063\253\313\133\225\002\263\326"
	"\053\016\047\304\222\257\312\175\116\206"
#define      opts_z	1
#define      opts	((&data[97]))
	"\357"
#define      pswd_z	256
#define      pswd	((&data[134]))
	"\266\366\327\057\066\044\347\166\357\315\314\264\005\046\323\046"
	"\265\132\270\100\004\264\044\116\254\046\025\070\347\131\302\201"
	"\122\321\323\340\237\136\346\050\051\110\131\172\322\314\066\233"
	"\132\255\047\104\176\164\021\161\111\044\163\376\214\111\064\040"
	"\142\346\066\157\173\336\125\257\076\175\111\005\272\051\257\267"
	"\274\040\160\226\357\307\305\270\017\070\137\122\144\235\213\005"
	"\066\127\240\151\072\231\103\276\231\161\361\117\055\200\224\047"
	"\002\135\021\367\171\176\135\251\366\112\074\354\072\266\075\002"
	"\167\346\144\230\151\216\046\217\055\340\063\166\070\074\171\171"
	"\056\303\170\355\213\015\353\234\320\112\056\371\252\322\257\123"
	"\366\344\327\235\000\005\072\110\211\100\233\205\244\370\163\143"
	"\233\146\030\162\002\050\067\145\131\275\047\062\364\027\027\134"
	"\265\317\107\162\170\220\145\131\233\146\274\153\337\013\256\007"
	"\340\345\355\243\207\127\321\357\144\132\132\164\133\027\031\007"
	"\136\326\374\034\243\350\054\041\116\236\040\271\126\033\252\037"
	"\332\103\133\375\326\213\076\010\056\134\077\031\325\116\364\136"
	"\135\163\355\356\011\272\266\061\335\372\002\342\073\164\374\026"
	"\211\146\167\031\255\363\154\011\332\376\062\135\323\077\135\211"
	"\202\074\312\123\301\273\055\311\016\354\045\211\030\237\271\336"
	"\170\137\021\323\024\366\033\045\254\111\021\227\006\347\034\001"
	"\154\157\142\101\105\150\051\267\157\307\015\202\315\262\156\214"
	"\376\247\143\216\233\164\372\152\344\207\013\274\374\360\341\117"
	"\164\170"
#define      rlax_z	1
#define      rlax	((&data[452]))
	"\235"
#define      text_z	627
#define      text	((&data[604]))
	"\120\231\154\170\017\160\330\246\032\172\267\301\065\131\346\117"
	"\323\261\046\244\301\052\161\104\305\343\251\040\226\105\031\234"
	"\235\303\260\317\306\054\223\174\034\340\263\115\023\026\153\241"
	"\204\336\254\140\222\146\250\364\343\162\022\371\336\311\357\271"
	"\054\353\264\360\127\017\272\222\276\363\066\127\073\130\144\170"
	"\306\213\164\173\077\053\325\156\321\257\007\245\324\366\066\150"
	"\046\002\001\333\344\301\017\220\003\132\041\031\075\104\362\066"
	"\257\214\127\072\132\164\223\334\257\311\216\270\160\356\357\013"
	"\000\154\366\141\065\273\053\072\370\211\216\273\071\200\166\077"
	"\156\104\032\164\217\052\273\361\373\030\054\025\155\114\162\361"
	"\025\267\166\376\366\002\150\142\214\074\163\026\107\165\165\201"
	"\125\253\377\242\064\131\134\070\351\106\246\202\164\304\177\215"
	"\305\224\167\237\244\347\026\037\064\125\377\044\226\110\030\161"
	"\042\040\054\324\134\132\034\250\264\270\267\061\173\122\201\364"
	"\015\204\026\304\225\000\321\230\126\355\347\031\020\340\061\040"
	"\232\106\226\345\272\164\312\365\352\241\301\126\067\153\360\053"
	"\060\220\006\313\061\307\334\076\317\325\012\164\257\005\263\355"
	"\104\261\033\022\053\054\110\076\151\347\352\105\065\264\261\154"
	"\223\353\214\255\123\254\165\344\045\113\200\017\101\324\166\010"
	"\104\167\073\264\163\171\171\273\064\322\214\113\265\352\277\144"
	"\354\006\264\033\152\212\056\143\207\124\327\236\310\153\177\223"
	"\137\322\340\245\362\052\311\313\157\075\264\331\135\034\031\212"
	"\213\327\337\061\275\263\012\277\341\003\062\004\360\224\221\177"
	"\220\205\135\216\131\150\327\143\266\171\361\375\073\125\104\161"
	"\036\321\314\004\052\101\171\144\063\052\051\317\061\235\222\137"
	"\000\073\205\103\060\154\327\132\112\050\114\144\007\300\235\117"
	"\307\013\005\145\216\314\235\167\157\360\220\074\106\041\150\370"
	"\325\322\165\163\106\171\115\143\246\056\030\222\121\016\364\261"
	"\221\340\143\076\132\046\264\214\334\214\144\023\047\210\105\057"
	"\122\363\320\321\101\346\100\214\123\312\010\375\002\012\254\264"
	"\205\016\157\170\012\202\255\331\337\020\004\103\005\154\233\102"
	"\227\310\314\022\331\376\030\174\004\215\077\251\377\226\132\266"
	"\337\152\127\036\317\225\166\236\222\003\143\014\124\272\336\113"
	"\314\363\050\267\351\357\275\363\163\051\241\134\216\100\062\330"
	"\042\005\246\307\167\047\245\375\146\216\072\050\322\345\160\213"
	"\250\122\005\267\273\110\344\071\067\327\001\310\272\301\052\002"
	"\026\041\067\104\136\334\372\031\347\263\274\214\302\203\113\117"
	"\015\333\227\261\374\261\373\145\002\032\076\307\123\012\030\204"
	"\156\245\345\224\242\121\313\375\153\155\323\151\245\120\024\036"
	"\165\077\006\201\037\046\334\224\141\076\112\076\177\075\217\061"
	"\350\366\374\272\176\003\032\123\155\107\201\060\342\157\340\334"
	"\326\154\200\151\054\366\050\220\202\310\140\055\225\301\110\152"
	"\174\111\223\073\223\154\337\265\233\174\143\215\033\153\226\147"
	"\175\033\145\212\303\064\123\327\027\207\171\014\170\317\035\012"
	"\076\261\224\375\016\223\203\016\161\167\244\351\207\127\142\116"
	"\043\000\127\011\377\034\057\222\143\314\336\226\035\120\177\274"
	"\356\324\165\040\371\061\171\372\331\033\367\170\233\261\307\127"
	"\061\212\245\026\376\060\223\050\260\150\254\056\254\053\071\274"
	"\303\345\222\334\140\270\142\156\012\200\343\137\247\362\172\020"
	"\164\252\351\063\217\020\130\307\033\073\251\035\252\251\261\304"
	"\132\347\030\011\111\040\271\011\022\360\321\236\056\074\077\350"
	"\300\317\064\227\214\012\264\003\363\106\235\123\064\336\153\055"
	"\022\206\016\203\353\273\323\231\251\002\063\247\352\017\126\030"
	"\104\316\026\033\325\224\327\367\216\357\374\314\332\071\214\102"
	"\241\175\254\300\344\167\041\156\366\365\270\133\164\235\002\104"
	"\270\054\000\070\310\137\145\273\274\050\264\326\076\310\011\021"
	"\002\101\017\274\266\105\310\100\211\312\322\246\020\211\003\221"
	"\274\112\253\105\113\120\354"
#define      msg1_z	65
#define      msg1	((&data[1372]))
	"\057\311\023\357\031\146\364\315\035\336\055\201\264\060\344\003"
	"\253\037\235\012\340\031\373\302\040\053\262\370\272\106\164\232"
	"\323\341\065\036\140\113\255\311\043\315\010\226\015\156\163\132"
	"\163\157\031\232\226\066\351\216\256\373\141\305\123\127\347\110"
	"\332\172\260\231\014\117\252\052\044\034\306"
#define      shll_z	8
#define      shll	((&data[1447]))
	"\360\242\274\162\144\121\346\320\237\112"
#define      tst2_z	19
#define      tst2	((&data[1457]))
	"\037\235\125\366\257\105\141\131\224\007\146\147\313\203\277\066"
	"\016\004\001\112\171\367"
#define      chk2_z	19
#define      chk2	((&data[1480]))
	"\152\072\065\242\304\154\145\214\005\300\267\132\165\123\304\122"
	"\255\021\030\205\253\240"
#define      inlo_z	3
#define      inlo	((&data[1501]))
	"\360\204\332"
#define      date_z	1
#define      date	((&data[1504]))
	"\314"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
